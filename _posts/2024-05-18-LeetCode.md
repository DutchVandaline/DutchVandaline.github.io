---
layout: single
title:  "LeetCode #1"
---
<br>

![image](https://github.com/DutchVandaline/DutchVandaline.github.io/assets/142364450/42bf7dab-a9e3-43b3-b2b7-324d5d195fd5)
<br>
I've started doing LeetCode. Of course, it's free plan but, if I get interest I will buy the premium version. Today is the first time so I am doing Explore. I am writing blog simultaniously like in "The Social Network".
<br>

# What I've Learned (After today's problems)
First, **hashmap**. Actually, I just don't get it.

### Disclaimer
 My LeetCode is free plan. I am posting just the free algorithms for now on. Also, I am using JAVA to code.

# 1. Two Sum
### My Solution
I just thought I can check all the numbers and add it to find the matching number of target. It takes a lot of time but, it's
safe and believable. 
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
    	int[] answer = new int[2];
    	
        for(int i = 0; i<nums.length; i++) {
        	for(int j = i+1; j < nums.length; j++) {
        		if(nums[i] + nums[j] == target) {
        			int[] resultarr = {i,j};
        			answer = resultarr;
        		}
        	}
        }
        return answer;
    }
}

```
### Solution
 So, Hashmap approach. This question is about hashmap. Splitting all the char values in String and finding if it matches or not. It's simple when we use array or list but takes a long time.<br>
 Here, we are using hashmap. For each characters on the String, we can count how many characters were found. We can check if `magazine` is including each characters.
 ```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> numMap = new HashMap<>();
        int n = nums.length;

        // Build the hash table
        for (int i = 0; i < n; i++) {
            numMap.put(nums[i], i);
        }

        // Find the complement
        for (int i = 0; i < n; i++) {
            int complement = target - nums[i];
            if (numMap.containsKey(complement) && numMap.get(complement) != i) {
                return new int[]{i, numMap.get(complement)};
            }
        }

        return new int[]{}; // No solution found
    }
} ```
Hashmap saves Key and Value in pair. Hashmap has a advantage of fast searching. `getOrDefault()` is for retrieving value rather than null.
We can set by `getOrDefault(r,0)` then null value is retrived as zero. It's not easy. I need to review the hashmap and other sort of things in java.<br>
