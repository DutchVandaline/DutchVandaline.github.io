---
layout: single
title:  "LeetCode #1"
---
<br>

![image](https://github.com/DutchVandaline/DutchVandaline.github.io/assets/142364450/42bf7dab-a9e3-43b3-b2b7-324d5d195fd5)
<br>
I've started doing LeetCode. Of course, it's free plan but, if I get interest I will buy the premium version. Today is the first time so I am doing Explore. I am writing blog simultaniously like in "The Social Network".
<br>

# What I've Learned (After today's problems)
First, **hashmap**. Hashmap is a array of keys and values. We can search values via key. The order is not important.  To use, `Map<Integer, Integer> numMap = new HashMap<>();`. To add `numMap.put(Key, Value);`. To get `numMap.get(key)`. For check, `numMap.containsKey(Key)`. 

### Disclaimer
 My LeetCode is free plan. I am posting just the free algorithms for now on. Also, I am using JAVA to code.

# 1. Two Sum
### My Solution
I just thought I can check all the numbers and add it to find the matching number of target. It takes a lot of time but, it's
safe and believable. 
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
    	int[] answer = new int[2];
    	
        for(int i = 0; i<nums.length; i++) {
        	for(int j = i+1; j < nums.length; j++) {
        		if(nums[i] + nums[j] == target) {
        			int[] resultarr = {i,j};
        			answer = resultarr;
        		}
        	}
        }
        return answer;
    }
}

```
### Solution
HashMap is a java utility that can make you access easily. Order is not important to consider. We can just find by key and get the value inside. To use, `Map<Integer, Integer> numMap = new HashMap<>();`. To add `numMap.put(Key, Value);`. To get `numMap.get(key)`. For check, `numMap.containsKey(Key)`. So the idea is to remove value from the target and search that value. 
 ```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> numMap = new HashMap<>();
        int n = nums.length;

        // Build the hash table
        for (int i = 0; i < n; i++) {
            numMap.put(nums[i], i);
        }

        // Find the complement
        for (int i = 0; i < n; i++) {
            int complement = target - nums[i];
            if (numMap.containsKey(complement) && numMap.get(complement) != i) {
                return new int[]{i, numMap.get(complement)};
            }
        }

        return new int[]{}; // No solution found
    }
}
```
