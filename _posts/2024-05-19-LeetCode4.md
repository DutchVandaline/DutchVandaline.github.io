---
layout: single
title:  "LeetCode #4"
---
<br>

![image](https://github.com/DutchVandaline/DutchVandaline.github.io/assets/142364450/42bf7dab-a9e3-43b3-b2b7-324d5d195fd5)
<br>
I've started doing LeetCode. Of course, it's free plan but, if I get interest I will buy the premium version. Today is the first time so I am doing Explore. I am writing blog simultaniously like in "The Social Network".
<br>

# What I've Learned
First, Sorting alphabetical and comparing between first and last value for continuous characters is astonishing idea.
Second, **Stack** I can use stack to check if it matched or not.
Third, **HashMap** for mapping two different values.


### Disclaimer
 My LeetCode is free plan. I am posting just the free algorithms for now on. Also, I am using JAVA to code.

# 14. Longest Common Prefix

### My Solution
I came up with comparing the first String with others and put it inside a list, combine at final step. It passed the given test but, when submitting it didn't worked. Problem was that it needs to be continuous. I didn't know how to do it so, I saw the solution.

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
    	String reference = strs[0];
    	ArrayList<Character> list = new ArrayList<>();
    	boolean add = true;

    	for(int i = 0; i<reference.length(); i++) {
    		for(int j =1; j<strs.length; j++) {
    			if(strs[j].indexOf(reference.charAt(i)) == -1) {
    				add = false;
    				break;
    			}
    				
    			else
    				add = true;
    		}
    		if(add)
    			list.add(reference.charAt(i));
    	}
    	
    	 StringBuilder sb = new StringBuilder();
         for (char c : list) {
             sb.append(c);
         }
    	
    	return sb.toString(); 
    }
}

```
### Solution
This question is tough. Sorting the array and comparing first and last value. Sorting alphabetical. How can I come up with that idea? Sorting and comparing the first and last is something. 

 ```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String s1 = strs[0];
        String s2 = strs[strs.length-1];
        int idx = 0;
        while(idx < s1.length() && idx < s2.length()){
            if(s1.charAt(idx) == s2.charAt(idx)){
                idx++;
            } else {
                break;
            }
        }
        return s1.substring(0, idx);
    }
}
```
<br>
# 20. Valid Parentheses

### My Solution
At a first glance, I thought it was easy. But, it took few hours to make a wrong answer. It is a tough question if you don't know about stack. I didn't know it too. So, I saw the Solution.

 ```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        Map<Character, Character> mapping = new HashMap<>();
        mapping.put(')', '(');
        mapping.put('}', '{');
        mapping.put(']', '[');

        for (char c : s.toCharArray()) {
            if (mapping.containsValue(c)) {
                stack.push(c);
            } else if (mapping.containsKey(c)) {
                if (stack.isEmpty() || mapping.get(c) != stack.pop()) {
                    return false;
                }
            }
        }

        return stack.isEmpty();        
    }
}
```
I didn't come up with `stack`. It could be more easier if I used stack. And mapping with hashmap is a great idea. I need to review this question again.
