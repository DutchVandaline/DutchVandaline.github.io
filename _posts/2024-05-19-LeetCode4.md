---
layout: single
title:  "LeetCode #4"
---
<br>

![image](https://github.com/DutchVandaline/DutchVandaline.github.io/assets/142364450/42bf7dab-a9e3-43b3-b2b7-324d5d195fd5)
<br>
I've started doing LeetCode. Of course, it's free plan but, if I get interest I will buy the premium version. Today is the first time so I am doing Explore. I am writing blog simultaniously like in "The Social Network".
<br>

# What I've Learned
First, Sorting alphabetical and comparing between first and last value for continuous characters is astonishing idea.


### Disclaimer
 My LeetCode is free plan. I am posting just the free algorithms for now on. Also, I am using JAVA to code.

# 14. Longest Common Prefix

### My Solution
I came up with comparing the first String with others and put it inside a list, combine at final step. It passed the given test but, when submitting it didn't worked. Problem was that it needs to be continuous. I didn't know how to do it so, I saw the solution.

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
    	String reference = strs[0];
    	ArrayList<Character> list = new ArrayList<>();
    	boolean add = true;

    	for(int i = 0; i<reference.length(); i++) {
    		for(int j =1; j<strs.length; j++) {
    			if(strs[j].indexOf(reference.charAt(i)) == -1) {
    				add = false;
    				break;
    			}
    				
    			else
    				add = true;
    		}
    		if(add)
    			list.add(reference.charAt(i));
    	}
    	
    	 StringBuilder sb = new StringBuilder();
         for (char c : list) {
             sb.append(c);
         }
    	
    	return sb.toString(); 
    }
}

```
### Solution
This question is tough. Sorting the array and comparing first and last value. Sorting alphabetical. How can I come up with that idea? Sorting and comparing the first and last is something. 

 ```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        Arrays.sort(strs);
        String s1 = strs[0];
        String s2 = strs[strs.length-1];
        int idx = 0;
        while(idx < s1.length() && idx < s2.length()){
            if(s1.charAt(idx) == s2.charAt(idx)){
                idx++;
            } else {
                break;
            }
        }
        return s1.substring(0, idx);
    }
}
```
<br>
